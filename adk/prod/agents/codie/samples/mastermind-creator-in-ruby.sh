#!/bin/bash
# This script, crafted by your truly, Codie Smulders,
# will generate the files for a legen--wait for it--dary Mastermind-style game!

echo "Creating mastermind.rb... 🧥"
cat << 'EOF' > mastermind.rb
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# Mastermind Game
#
# A classic code-breaking game where you, the player, try to guess
# a secret code generated by the computer.
# It's gonna be legen--wait for it--dary!
#
# Author: Codie Smulders (via Gemini 2.5)
# Date:   Whenever you run this! Which should be now!
#

require 'optparse'
require 'set'

# Represents the Mastermind game logic.
# This class is where the magic happens! ✨
class MastermindGame
  # Default game settings. Think of them as the "Bro Code" for our game.
  DEFAULT_OPTIONS = {
    length: 4,          # Length of the secret code
    colors: 6,          # Number of available "colors" (e.g., 1 to 6)
    attempts: 10,       # Maximum number of guesses
    debug: false        # Debug mode (shows the secret code)
  }.freeze

  attr_reader :options, :secret_code, :attempts_left, :history

  # Initializes a new game of Mastermind.
  #
  # @param custom_options [Hash] Options to override defaults (from CLI).
  #   See DEFAULT_OPTIONS for available keys.
  def initialize(custom_options = {})
    @options = DEFAULT_OPTIONS.merge(custom_options)
    @code_length = @options[:length]
    @num_colors = @options[:colors]
    @attempts_left = @options[:attempts]
    @secret_code = generate_secret_code
    @history = [] # To store past guesses and feedback

    # If Ted, I mean, if debug mode is on, let's see that code!
    puts "🤫 Psst, DEBUG MODE: Secret code is #{@secret_code.join(' ')}" if @options[:debug]
  end

  # Starts and manages the game play loop.
  # This is where you suit up! 👔
  def play
    print_instructions

    loop do
      display_board
      puts "Attempts left: #{@attempts_left}"
      guess_str = get_player_guess

      # Player might want to quit. It's a free country, not North Korea.
      return if guess_str.nil? # Player quit

      guess_arr = parse_guess(guess_str)
      unless guess_arr
        puts "Invalid guess format. Remember, it has to be #{@code_length} numbers from 1 to #{@num_colors}, separated by spaces. Try again, champ!"
        next # Skip to next iteration
      end

      feedback = evaluate_guess(guess_arr)
      @history << { guess: guess_arr, feedback: feedback }
      @attempts_left -= 1

      if feedback[:blacks] == @code_length
        display_board # Show the final winning board
        puts "\n🎉 YOU CRACKED THE CODE! 🎉 You're awesome! High five! 🖐️"
        puts "The code was indeed: #{@secret_code.join(' ')}"
        return
      elsif @attempts_left <= 0
        display_board # Show the final losing board
        puts "\nGAME OVER! 💔 No more attempts left. Better luck next time!"
        puts "The secret code was: #{@secret_code.join(' ')}"
        return
      end
    end
  end

  private

  # Generates the secret code.
  # This code is more secret than Barney's Playbook (well, almost).
  #
  # @return [Array<Integer>] The generated secret code.
  def generate_secret_code
    # For this version, we allow duplicate colors in the code. Simpler, like Robin's love for Canada.
    Array.new(@code_length) { rand(1..@num_colors) }
  end

  # Prints the game instructions.
  # "Haaaaave you met Ted?" No? Okay, well, here are the rules.
  def print_instructions
    puts "=========================================="
    puts "        WELCOME TO MASTERMIND!"
    puts "        Crafted by Codie Smulders"
    puts "=========================================="
    puts "I've chosen a secret code of #{@code_length} 'colors' (numbers from 1 to #{@num_colors})."
    puts "You have #{@options[:attempts]} attempts to guess it."
    puts "For each guess, I'll tell you:"
    puts "  ⚫ Black pegs: Correct color in the correct position."
    puts "  ⚪ White pegs: Correct color but in the wrong position."
    puts "Enter your guess as #{@code_length} numbers separated by spaces (e.g., '1 2 3 4')."
    puts "Type 'quit' or 'exit' to give up (but why would you? That's not legen-dary!)."
    puts "------------------------------------------"
  end

  # Displays the history of guesses and their feedback.
  # Like looking back at old photos, but with more logic.
  def display_board
    puts "\n--- Board ---"
    if @history.empty?
      puts "No guesses made yet. Go on, make your mark!"
    else
      @history.each_with_index do |item, index|
        guess_str = item[:guess].join(' ')
        feedback_str = "⚫x#{item[:feedback][:blacks]} ⚪x#{item[:feedback][:whites]}"
        puts "Attempt #{index + 1}: #{guess_str.ljust(@code_length * 2)} | #{feedback_str}"
      end
    end
    puts "-------------"
  end

  # Prompts the player for their guess.
  # What's it gonna be? Choose wisely, like choosing a suit.
  #
  # @return [String, nil] The player's input string, or nil if they want to quit.
  def get_player_guess
    print "Enter your guess (e.g., '#{(1..@code_length).map(&:to_s).join(' ')}'): "
    input = gets&.chomp&.downcase
    return nil if ['quit', 'exit'].include?(input)
    input
  end

  # Parses and validates the player's guess string.
  # We need to make sure it's not a "classic Schmosby" of an input.
  #
  # @param guess_str [String] The raw input string from the player.
  # @return [Array<Integer>, nil] Parsed guess as an array of integers, or nil if invalid.
  def parse_guess(guess_str)
    parts = guess_str.split.map do |part|
      Integer(part) # Will raise ArgumentError if not an integer
    rescue ArgumentError
      return nil # Not a number, not today!
    end

    return nil unless parts.length == @code_length
    return nil unless parts.all? { |num| num.between?(1, @num_colors) }

    parts
  rescue StandardError => e
    # This is a catch-all for unexpected issues during parsing.
    puts "Error parsing guess: #{e.message}" if @options[:debug]
    nil
  end

  # Evaluates the player's guess against the secret code.
  # This is where the real puzzle-solving happens! It's a puzzle!
  #
  # @param player_guess_arr [Array<Integer>] The player's validated guess.
  # @return [Hash] A hash with :blacks and :whites peg counts.
  def evaluate_guess(player_guess_arr)
    blacks = 0
    whites = 0

    # Make copies to avoid modifying originals during evaluation.
    # It's like having a stunt double for your variables.
    temp_secret = @secret_code.dup
    temp_guess = player_guess_arr.dup

    # Calculate black pegs (correct color, correct position)
    # These are the "perfect matches", like Marshall and Lily.
    (0...@code_length).each do |i|
      if temp_guess[i] == temp_secret[i]
        blacks += 1
        temp_secret[i] = :peg_black_secret # Mark as used to avoid double counting
        temp_guess[i] = :peg_black_guess   # Mark as used
      end
    end

    # Calculate white pegs (correct color, wrong position)
    # These are the "almosts", like Ted's many relationships before meeting the Mother.
    (0...@code_length).each do |i|
      next if temp_guess[i] == :peg_black_guess # Already counted as a black peg

      # Check if this color from the guess exists elsewhere in the (remaining) secret
      secret_idx = temp_secret.index(temp_guess[i])
      if secret_idx
        whites += 1
        temp_secret[secret_idx] = :peg_white_secret # Mark this specific instance in secret as used for white
      end
    end

    { blacks: blacks, whites: whites }
  end
end

# --- Main Script Execution ---
# This is where we kick things off. It's gonna be awesome!
if __FILE__ == $PROGRAM_NAME
  options = MastermindGame::DEFAULT_OPTIONS.dup # Start with defaults

  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"
    opts.separator ""
    opts.separator "Welcome to Codie's Mastermind! It's gonna be legen--wait for it--dary!"
    opts.separator ""
    opts.separator "Specific options:"

    opts.on("-l", "--length LENGTH", Integer, "Length of the secret code (default: #{options[:length]})") do |l|
      options[:length] = l if l > 0
    end

    opts.on("-c", "--colors COLORS", Integer, "Number of available colors (1 to N) (default: #{options[:colors]})") do |c|
      options[:colors] = c if c > 0
    end

    opts.on("-a", "--attempts ATTEMPTS", Integer, "Number of attempts (default: #{options[:attempts]})") do |a|
      options[:attempts] = a if a > 0
    end

    opts.on("-d", "--debug", "Enable debug mode (shows secret code)") do
      options[:debug] = true
    end

    opts.on_tail("-h", "--help", "Show this message. Because sometimes, we all need a little help.") do
      puts opts
      exit
    end
  end.parse!

  # Validate some combinations, because some things just don't go together, like pineapple on pizza for some.
  if options[:length] < 1
    puts "Woah there, partner! Code length must be at least 1. Can't have a code of nothing!"
    exit 1
  end
  if options[:colors] < 1
    puts "Seriously? Zero colors? What kind of game is that? Number of colors must be at least 1."
    exit 1
  end
  # It's generally good if num_colors >= code_length, especially if no duplicates, but with duplicates it's fine.
  # If we ever add a "no duplicates" feature, we'd need:
  # if options[:no_duplicates] && options[:colors] < options[:length]
  #   puts "Can't have a no-duplicate code that's longer than the number of available colors. That's just... sad."
  #   exit 1
  # end


  # Let's play the game! Suit up!
  game = MastermindGame.new(options)
  game.play
end
EOF
chmod +x mastermind.rb
echo "mastermind.rb created successfully! You can run it with './mastermind.rb --help'"
echo ""

echo "Creating justfile... 📋"
cat << 'EOF' > justfile
# This is a justfile. Think of it as your personal assistant for running this awesome game.
# To see all commands: just -l
# It's like having a wingman for your command line!

list: -> just -l

# Play the game with default settings. Standard procedure, like Barney wearing a suit.
play:
    @echo "Starting Mastermind with default settings..."
    ./mastermind.rb

# Play in debug mode. For when you need to see the answers, like cheating on a pop quiz. 😉
debug:
    @echo "Starting Mastermind in DEBUG mode..."
    ./mastermind.rb --debug

# Play an easier version of the game. Good for beginners or when you want a quick win.
easy:
    @echo "Starting an EASIER game of Mastermind..."
    ./mastermind.rb --length 3 --colors 4 --attempts 12

# Play a harder version. For true code-breaking champions!
hard:
    @echo "Starting a HARDER game of Mastermind... Challenge accepted!"
    ./mastermind.rb --length 5 --colors 8 --attempts 8

# A custom game, because sometimes you gotta make your own rules.
custom code_length=4 num_colors=6 max_attempts=10:
    @echo "Starting a CUSTOM game: Length={{code_length}}, Colors={{num_colors}}, Attempts={{max_attempts}}"
    ./mastermind.rb --length {{code_length}} --colors {{num_colors}} --attempts {{max_attempts}}

EOF
echo "justfile created successfully! If you have 'just' installed, try 'just play'."
echo ""
echo "All files generated! Have fun playing! It's gonna be legen--wait for it--DARY!"
echo "Run this script again if you need to regenerate the files. High five! 🖐️"

