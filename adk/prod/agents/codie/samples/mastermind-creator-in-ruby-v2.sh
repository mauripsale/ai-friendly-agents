#!/bin/bash
# This script, updated by your favorite code execution specialist, Codie Smulders,
# will generate the files for an EVEN MORE legen--wait for it--dary Mastermind game!
# Now with unique colors and a more colorful interface! ✨🌈

echo "Creating mastermind.rb (v2.0)... 🧥✨"
cat << 'EOF' > mastermind.rb
#!/usr/bin/env ruby
# frozen_string_literal: true

#
# Mastermind Game v2.0
#
# A classic code-breaking game where you, the player, try to guess
# a secret code of UNIQUE colors generated by the computer.
# Now with actual color names for a more vibrant experience!
# It's gonna be legen--wait for it--dary! And colorful!
#
# Author: Codie Smulders (via Gemini 2.5)
# Date:   The day you decided to upgrade your gaming experience!
#

require 'optparse'
require 'set'

# Represents the Mastermind game logic.
# This class is where the magic happens! ✨ Now with more flair!
class MastermindGame
  # Default game settings. Think of them as the "Bro Code" for our game.
  DEFAULT_OPTIONS = {
    length: 4,          # Length of the secret code
    colors: 6,          # Number of available "colors" (e.g., 1 to 6)
    attempts: 10,       # Maximum number of guesses
    debug: false        # Debug mode (shows the secret code)
  }.freeze

  # Color palette! We're not monsters, we like pretty things.
  # Up to 9 colors, mapping numbers 1-9.
  COLOR_NAMES = [
    "Blue", "Yellow", "Red", "Green", "Purple", "Orange",
    "Cyan", "Magenta", "Brown" # For when 6 colors just isn't enough
  ].freeze

  attr_reader :options, :secret_code, :attempts_left, :history

  # Initializes a new game of Mastermind.
  #
  # @param custom_options [Hash] Options to override defaults (from CLI).
  #   See DEFAULT_OPTIONS for available keys.
  def initialize(custom_options = {})
    @options = DEFAULT_OPTIONS.merge(custom_options)
    @code_length = @options[:length]
    @num_colors = @options[:colors] # This is the COUNT of colors to use from COLOR_NAMES
    @attempts_left = @options[:attempts]

    validate_options! # Important new step!

    @secret_code = generate_secret_code
    @history = [] # To store past guesses and feedback

    # If Ted, I mean, if debug mode is on, let's see that code!
    if @options[:debug]
      puts "🤫 Psst, DEBUG MODE: Secret code is #{code_to_color_string(@secret_code)} (#{@secret_code.join})"
    end
  end

  # Validates game options. Some rules are non-negotiable, like "bros before... well, you know."
  def validate_options!
    if @code_length > @num_colors
      puts "🚨 Configuration Error: Code length (#{@code_length}) cannot be greater than the number of available unique colors (#{@num_colors})."
      puts "That's like trying to find 5 unique girlfriends in a town with only 4 women. Not gonna happen, buddy."
      exit 1
    end
    if @num_colors > COLOR_NAMES.length
      puts "🎨 Warning: Requested #{@num_colors} colors, but we only have names for #{COLOR_NAMES.length}."
      puts "Beyond #{COLOR_NAMES.length}, they'll be referred to as 'Color N'. Consider it abstract art."
      # This is a warning, not an error, game can proceed.
    end
    if @num_colors > 9
        puts "🔢 Heads up: Using more than 9 colors means inputs like '10' would be ambiguous with '1' then '0'."
        puts "    For now, stick to numbers 1-9 for colors if entering guesses without spaces."
        # Could add logic to switch to space-separated input if @num_colors > 9, but keeping it simple for now.
    end
  end


  # Starts and manages the game play loop.
  # This is where you suit up! 👔
  def play
    print_instructions

    loop do
      display_board
      puts "Attempts left: #{@attempts_left}"
      guess_str = get_player_guess

      # Player might want to quit. It's a free country, not North Korea.
      return if guess_str.nil? # Player quit

      guess_arr = parse_guess(guess_str)
      unless guess_arr
        # Specific error messages handled in parse_guess now
        next # Skip to next iteration
      end

      feedback = evaluate_guess(guess_arr)
      @history << { guess: guess_arr, feedback: feedback }
      @attempts_left -= 1

      if feedback[:blacks] == @code_length
        display_board # Show the final winning board
        puts "\n🎉 YOU CRACKED THE CODE! 🎉 You're awesome! High five! 🖐️"
        puts "The code was indeed: #{code_to_color_string(@secret_code)} (#{@secret_code.join})"
        return
      elsif @attempts_left <= 0
        display_board # Show the final losing board
        puts "\nGAME OVER! 💔 No more attempts left. Better luck next time!"
        puts "The secret code was: #{code_to_color_string(@secret_code)} (#{@secret_code.join})"
        return
      end
    end
  end

  private

  # Generates the secret code with UNIQUE colors.
  # This code is more exclusive than the Fiero owner's club.
  #
  # @return [Array<Integer>] The generated secret code.
  def generate_secret_code
    available_peg_numbers = (1..@num_colors).to_a
    available_peg_numbers.sample(@code_length)
  end

  # Converts an array of code numbers to a displayable color string.
  # @param code_array [Array<Integer>] Array of numbers representing colors.
  # @return [String] A string of color names.
  def code_to_color_string(code_array)
    code_array.map { |num| get_color_name(num) }.join(' ')
  end

  # Gets the color name for a given number.
  # @param number [Integer] The number of the color (1-indexed).
  # @return [String] The name of the color.
  def get_color_name(number)
    # Numbers are 1-indexed for player, array is 0-indexed
    if number.is_a?(Integer) && number >= 1 && number <= COLOR_NAMES.length
      COLOR_NAMES[number - 1]
    elsif number.is_a?(Integer) && number >= 1
      "Color ##{number}" # Fallback for colors beyond our named palette
    else
      "Unknown" # Should not happen with valid numbers
    end
  end

  # Prints the game instructions.
  # "Haaaaave you met Ted?" No? Okay, well, here are the rules for our FANCY new game.
  def print_instructions
    puts "================================================"
    puts "     WELCOME TO MASTERMIND - COLOR EDITION!"
    puts "        Upgraded by Codie Smulders"
    puts "================================================"
    puts "I've chosen a secret code of #{@code_length} UNIQUE 'colors'."
    puts "The available colors (and their input numbers) are:"
    (1..@num_colors).each do |i|
      puts "  #{i}: #{get_color_name(i)}"
    end
    puts "You have #{@options[:attempts]} attempts to guess it."
    puts "For each guess, I'll tell you:"
    puts "  ⚫ Black pegs: Correct color in the correct position."
    puts "  ⚪ White pegs: Correct color but in the wrong position."
    puts "Enter your guess as #{@code_length} unique numbers WITHOUT spaces (e.g., '#{(1..@code_length).to_a.join}')."
    puts "Type 'quit' or 'exit' to give up (but true legends never quit!)."
    puts "------------------------------------------------"
  end

  # Displays the history of guesses and their feedback.
  # Like looking back at old photos, but now they're in color!
  def display_board
    puts "\n--- Board ---"
    if @history.empty?
      puts "No guesses made yet. Go on, make your colorful mark!"
    else
      @history.each_with_index do |item, index|
        guess_color_str = code_to_color_string(item[:guess])
        # Pad based on longest possible color string (approx @code_length * avg_color_name_length + spaces)
        # For simplicity, let's use a generous fixed padding or adapt.
        # A more robust padding would calculate max possible string length.
        # Max color name length is around 7 ("Magenta"). So, @code_length * 8 should be enough.
        padding = @code_length * 8 
        feedback_str = "⚫x#{item[:feedback][:blacks]} ⚪x#{item[:feedback][:whites]}"
        puts "Attempt #{index + 1}: #{guess_color_str.ljust(padding)} | #{feedback_str}"
      end
    end
    puts "-------------"
  end

  # Prompts the player for their guess.
  # What's it gonna be? Choose wisely, like choosing a tie for a wedding.
  #
  # @return [String, nil] The player's input string, or nil if they want to quit.
  def get_player_guess
    example_guess = (1..@code_length).to_a.join
    print "Enter your guess (#{@code_length} unique digits 1-#{@num_colors}, e.g., '#{example_guess}'): "
    input = gets&.chomp&.downcase
    return nil if ['quit', 'exit'].include?(input)
    input
  end

  # Parses and validates the player's guess string (now expecting no spaces).
  # We need to make sure it's not a "classic Schmosby" of an input.
  #
  # @param guess_str [String] The raw input string from the player.
  # @return [Array<Integer>, nil] Parsed guess as an array of integers, or nil if invalid.
  def parse_guess(guess_str)
    unless guess_str.match?(/^\d+$/) # Check if the string contains only digits
      puts "Invalid input: Please enter only numbers. No funny business, Schmosby!"
      return nil
    end

    parts = guess_str.chars.map(&:to_i)

    unless parts.length == @code_length
      puts "Invalid guess length. Expected #{@code_length} digits, got #{parts.length}. Measure twice, cut once!"
      return nil
    end

    unless parts.all? { |num| num.between?(1, @num_colors) }
      puts "Invalid numbers in guess. Use numbers from 1 to #{@num_colors}. Stay within the lines!"
      return nil
    end

    unless parts.uniq.length == parts.length
      puts "Duplicate numbers in guess. The code (and your guess) must use unique colors. One of a kind, like Barney's suits!"
      return nil
    end

    parts
  rescue StandardError => e
    # This is a catch-all for unexpected issues during parsing.
    puts "Error parsing guess: #{e.message}" if @options[:debug]
    nil
  end

  # Evaluates the player's guess against the secret code.
  # This is where the real puzzle-solving happens! It's a puzzle!
  # (Logic for blacks and whites remains largely the same, but benefits from unique items.)
  #
  # @param player_guess_arr [Array<Integer>] The player's validated guess.
  # @return [Hash] A hash with :blacks and :whites peg counts.
  def evaluate_guess(player_guess_arr)
    blacks = 0
    whites = 0

    # Since codes are unique, evaluation is simpler.
    # No need to mark items as :peg_black_secret etc.
    # We can directly compare and count.

    # Calculate black pegs (correct color, correct position)
    # These are the "perfect matches", like Marshall and Lily.
    (0...@code_length).each do |i|
      if player_guess_arr[i] == @secret_code[i]
        blacks += 1
      end
    end

    # Calculate white pegs (correct color, wrong position)
    # These are the "almosts", like Ted's many relationships before meeting the Mother.
    # Count common elements, then subtract black pegs.
    # (This works because both secret and guess have unique elements)
    # Note: player_guess_arr and @secret_code might have different orderings.
    # Common elements between the two arrays:
    common_elements = (player_guess_arr & @secret_code).length
    whites = common_elements - blacks

    { blacks: blacks, whites: whites }
  end
end

# --- Main Script Execution ---
# This is where we kick things off. It's gonna be awesome!
if __FILE__ == $PROGRAM_NAME
  options = MastermindGame::DEFAULT_OPTIONS.dup # Start with defaults

  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"
    opts.separator ""
    opts.separator "Welcome to Codie's Upgraded Mastermind! It's gonna be legen--wait for it--dary AND colorful!"
    opts.separator ""
    opts.separator "Specific options:"

    opts.on("-l", "--length LENGTH", Integer, "Length of the secret code (default: #{options[:length]}). Must be <= number of colors.") do |l|
      options[:length] = l if l > 0
    end

    opts.on("-c", "--colors COLORS", Integer, "Number of available unique colors (1 to N, max #{MastermindGame::COLOR_NAMES.length} named, default: #{options[:colors]})") do |c|
      options[:colors] = c if c.between?(1, MastermindGame::COLOR_NAMES.length + 5) # Allow a few more than named
    end

    opts.on("-a", "--attempts ATTEMPTS", Integer, "Number of attempts (default: #{options[:attempts]})") do |a|
      options[:attempts] = a if a > 0
    end

    opts.on("-d", "--debug", "Enable debug mode (shows secret code)") do
      options[:debug] = true
    end

    opts.on_tail("-h", "--help", "Show this message. Because sometimes, we all need a little help, like Ted finding 'the one'.") do
      puts opts
      exit
    end
  end.parse!

  # Initial validation passed to the class constructor now.
  # Let's play the game! Suit up!
  begin
    game = MastermindGame.new(options)
    game.play
  rescue SystemExit # Catch exits from OptionParser or our validation
    # Already handled, just exit cleanly
  rescue StandardError => e
    puts "An unexpected error occurred: #{e.message}"
    puts "If you're feeling adventurous, run with --debug for more info (maybe)."
    puts e.backtrace.join("\n") if options[:debug] # Show backtrace if debug is on
  end
end
EOF
chmod +x mastermind.rb
echo "mastermind.rb (v2.0) created successfully! You can run it with './mastermind.rb --help'"
echo ""

echo "Creating justfile (checking if updates needed)... 📋"
# The justfile commands should still work fine.
# The 'easy' and 'hard' modes might need adjustment if defaults made them invalid
# e.g., if length > colors. But our defaults (L3,C4 and L5,C8) are fine.
cat << 'EOF' > justfile
# This is a justfile for Mastermind v2.0. Your command-line wingman!
# To see all commands: just -l
# It's like having a playbook for legendary gaming sessions.

list: -> just -l

# Play the game with default settings. Standard procedure, like Barney wearing a suit.
play:
    @echo "Starting Mastermind (Color Edition) with default settings..."
    ./mastermind.rb

# Play in debug mode. For when you need to see the answers, like knowing the Playbook's secrets. 😉
debug:
    @echo "Starting Mastermind (Color Edition) in DEBUG mode..."
    ./mastermind.rb --debug

# Play an easier version of the game. Good for beginners or when you want a quick win.
# Default: Length 3, Colors 4, Attempts 12. (L=3, C=4 means C > L, which is good for unique)
easy:
    @echo "Starting an EASIER game of Mastermind (Color Edition)..."
    ./mastermind.rb --length 3 --colors 4 --attempts 12

# Play a harder version. For true code-breaking champions!
# Default: Length 5, Colors 8, Attempts 8. (L=5, C=8 means C > L)
hard:
    @echo "Starting a HARDER game of Mastermind (Color Edition)... Challenge accepted!"
    ./mastermind.rb --length 5 --colors 8 --attempts 8

# A custom game, because sometimes you gotta make your own rules.
custom code_length=4 num_colors=6 max_attempts=10:
    @echo "Starting a CUSTOM game: Length={{code_length}}, Colors={{num_colors}}, Attempts={{max_attempts}}"
    ./mastermind.rb --length {{code_length}} --colors {{num_colors}} --attempts {{max_attempts}}

EOF
echo "justfile created/updated successfully! If you have 'just' installed, try 'just play'."
echo ""
echo "All files generated for Mastermind v2.0! Have fun playing the new colorful and unique challenge!"
echo "Run this script again if you need to regenerate the files. It's gonna be... wait for it... even more DARY!"
echo "High five! 🖐️🌈"

